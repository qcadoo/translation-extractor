%% name = Localizer::Parser::Ext

root = lines("")

lines(prefix) = (line(prefix)*):lines ~output(lines)

line(prefix) = relevant(prefix)
             | block(prefix)
             | < junk > { text }

relevant(prefix) = single_call(prefix)
                 | chained_call(prefix)
                 | scope(prefix)

block(prefix) = OPEN:op lines(prefix):li CLOSE:cl { [op, li, cl] }

scope(prefix)       = < EXT DOT meth_of_type("scope"):ident
                      LPAREN string:param COMMA >
                      ~join_keys(prefix, param):new_prefix
                      block(new_prefix):lines_src
                      RPAREN:right_src
                      { [text, lines_src, right_src] }

single_call(prefix) = < THIS DOT meth_of_type("setter"):ident
                      LPAREN > string:value RPAREN:right_src
                      ~translate_setter_to_key(ident):key
                      ~translate(prefix, key, value):translated_value
                      { [text, translated_value, right_src] }

chained_call(prefix) = < THIS DOT meth_of_type("finder"):ident
                      LPAREN string:key RPAREN:right_src
                      DOT meth_of_type("any")
                      LPAREN > string:value RPAREN:right_src
                      ~translate(prefix, key, value):translated_value
                      { [text, translated_value, right_src] }

string = STRING:raw ~make_string(raw)

meth_of_type(type) = IDENTIFIER:i &{ matches_type? i, type } { i }

junk = SEPARATOR
     | JUNK_EXPR

JUNK_EXPR = </[^;{}]+/>  { nil }
SEPARATOR = </\s*\;\s*/> { nil }
OPEN      = </\s*\{\s*/> { text }
CLOSE     = </\s*\}\s*/> { text }
LPAREN    = </\s*\(\s*/> { text }
RPAREN    = </\s*\)\s*/> { text }
COMMA     = </\s*\,\s*/> { nil }
STRING    = </\'([^']|\\.)*\'|\"([^"]|\\.)*\"/> { text }

DOT  = "."
EXT  = "Ext"
THIS = "this"

IDENTIFIER = </\w+/> { text }
